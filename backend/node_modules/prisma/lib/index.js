'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var MATH_ROUND = Math.round;
var MATH_MAX = Math.max;
var MATH_MIN = Math.min;
var OBJECT_FREEZE = Object.freeze;

var SHORTHAND_REGEXP = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var DEFAULT_HEX_CODE_VALUE = '000000';
var L_THRESHOLD = Math.sqrt(1.05 * 0.05) - 0.05;
var BRIGHTNESS_THRESHOLD = 130;

/**
 * get the full six-character hexcode from any shorthand values
 *
 * @param {string} color=DEFAULT_HEX_CODE_VALUE
 * @returns {string}
 */
var getProperHex = function getProperHex() {
  var color = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_HEX_CODE_VALUE : arguments[0];

  return color.replace(SHORTHAND_REGEXP, function (match, red, green, blue) {
    return '' + red + red + green + green + blue + blue;
  }).replace('#', '');
};

/**
 * convenience function to round fraction to two digits
 *
 * @param {number} number
 * @returns {number}
 */
var roundToTwoDigits = function roundToTwoDigits(number) {
  return MATH_ROUND(number * 100) / 100;
};

/**
 * based on array of hsl / hsla values,
 * return built string of comma-separated hsl CSS values
 *
 * @param {Array} hsla
 * @returns {string}
 */
var getHslaString = function getHslaString(hsla) {
  return hsla.reduce(function (hslaValueString, hslaPart, index) {
    var isHue = index === 0;
    var isAlpha = index === 3;

    if (isHue) {
      return hslaValueString + hslaPart;
    }

    if (isAlpha) {
      return hslaValueString + ', ' + hslaPart;
    }

    return hslaValueString + ', ' + MATH_ROUND(hslaPart * 100) + '%';
  }, '');
};

/**
 * determine whether the foreground color for the text
 * used with the color as a background color should
 * be dark (preferrably black), based on general brightness guideliness
 *
 * @param {Array<number>} rgb
 * @param {number} brightnessThreshold
 * @returns {boolean}
 */
var shouldForegroundBeDark = function shouldForegroundBeDark(rgb, brightnessThreshold) {
  var brightnessValue = rgb.reduce(function (currentBrightnessValue, colorPart, colorPartIndex) {
    switch (colorPartIndex) {
      case 0:
        return currentBrightnessValue + colorPart * colorPart * 0.241;

      case 1:
        return currentBrightnessValue + colorPart * colorPart * 0.691;

      case 2:
        return currentBrightnessValue + colorPart * colorPart * 0.068;
    }
  }, 0);

  return Math.sqrt(brightnessValue) >= brightnessThreshold;
};

/**
 * determine whether the foreground color for the text
 * used with the color as a background color should
 * be dark (preferrably black), based on relative
 * luminance definitions in the spec:
 *
 * https://www.w3.org/TR/WCAG20/#relativeluminancedef
 *
 * @param {Array} rgb
 * @returns {boolean}
 */
var shouldForegroundBeDarkW3C = function shouldForegroundBeDarkW3C(rgb) {
  var L = rgb.reduce(function (currentL, color, colorIndex) {
    var updatedColor = color / 255;

    if (updatedColor <= 0.03928) {
      updatedColor /= 12.92;
    } else {
      updatedColor = Math.pow((updatedColor + 0.055) / 1.055, 2.4);
    }

    switch (colorIndex) {
      case 0:
        return currentL + 0.2126 * updatedColor;

      case 1:
        return currentL + 0.7152 * updatedColor;

      case 2:
        return currentL + 0.0722 * updatedColor;
    }
  }, 0);

  return L > L_THRESHOLD;
};

/**
 * converts string to integer hash value
 *
 * @param {string} string
 * @returns {number}
 */
var hashCode = function hashCode(string) {
  var hash = 0,
      index = string.length;

  for (; index--;) {
    hash = string.charCodeAt(index) + ((hash << 5) - hash);
  }

  return hash;
};

/**
 * convert integer value to hex code
 *
 * @param {number} integer
 * @param {string} defaultHex
 * @returns {string}
 */
var integerToHex = function integerToHex(integer, defaultHex) {
  var hex = (integer >> 24 & 0xFF).toString(16) + (integer >> 16 & 0XFF).toString(16) + (integer >> 8 & 0xFF).toString(16) + (integer & 0xFF).toString(16);

  if (!hex) {
    return defaultHex;
  }

  if (hex.length < 6) {
    var hexCharArray = [];

    for (var index = 0; index < 6; index++) {
      hexCharArray.push(hex[index] || '0');
    }

    return hexCharArray.join('');
  }

  return hex.substring(0, 6);
};

/**
 * based on string passed, return hex code generated
 * from hashed value
 *
 * @param {string} string
 * @param {string} defaultHex
 * @returns {string}
 */
var stringToHex = function stringToHex(string, defaultHex) {
  if (!string) {
    return defaultHex;
  }

  var hash = hashCode(string);

  return integerToHex(hash, defaultHex).substring(0, 6);
};

/**
 * build RGB color from hashed string value
 *
 * @param {string} hex
 * @returns {Array<number>}
 */
var stringToRgb = function stringToRgb(hex) {
  var red = parseInt(hex.substring(0, 2), 16);
  var green = parseInt(hex.substring(2, 4), 16);
  var blue = parseInt(hex.substring(4, 6), 16);

  return [red, green, blue];
};

/**
 * based on rgb array, return hsl array value
 *
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @returns {Array}
 */
var rgbToHsl = function rgbToHsl(_ref) {
  var _ref2 = _slicedToArray(_ref, 3);

  var red = _ref2[0];
  var green = _ref2[1];
  var blue = _ref2[2];

  var fractionalRed = red / 255;
  var fractionalGreen = green / 255;
  var fractionalBlue = blue / 255;

  var max = MATH_MAX(fractionalRed, fractionalGreen, fractionalBlue);
  var min = MATH_MIN(fractionalRed, fractionalGreen, fractionalBlue);

  var luminance = (max + min) / 2;

  if (max === min) {
    return [0, 0, luminance];
  }

  var delta = max - min;
  var saturation = luminance > 0.5 ? delta / (2 - max - min) : delta / (max + min);

  var hue = void 0;

  switch (max) {
    case fractionalRed:
      hue = (fractionalGreen - fractionalBlue) / delta + (fractionalGreen < fractionalBlue ? 6 : 0);
      break;

    case fractionalGreen:
      hue = (fractionalBlue - fractionalRed) / delta + 2;
      break;

    case fractionalBlue:
      hue = (fractionalRed - fractionalGreen) / delta + 4;
      break;
  }

  hue *= 60;

  return [MATH_ROUND(MATH_MAX(0, hue)), roundToTwoDigits(saturation), roundToTwoDigits(luminance)];
};

/**
 * return object with a variety of color options for the developer
 *
 * @param {string} value
 * @param {object} options={}
 * @param {string} [options.defaultHex=DEFAULT_HEX_CODE_VALUE]
 * @param {number} [options.brightnessThreshold=BRIGHTNESS_THRESHOLD]
 * @param {number} [options.opacity=1]
 * @returns {object}
 */
var createPrisma = function createPrisma(value) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var _options$defaultHex = options.defaultHex;
  var defaultHex = _options$defaultHex === undefined ? DEFAULT_HEX_CODE_VALUE : _options$defaultHex;
  var _options$brightnessTh = options.brightnessThreshold;
  var brightnessThreshold = _options$brightnessTh === undefined ? BRIGHTNESS_THRESHOLD : _options$brightnessTh;
  var _options$opacity = options.opacity;
  var opacity = _options$opacity === undefined ? 1 : _options$opacity;


  if (opacity > 1 || opacity < 0) {
    throw new SyntaxError('Your opacity value is invalid; it needs to be a decimal value between 0 and 1.');
  }

  if (brightnessThreshold < 0 || brightnessThreshold > 255) {
    throw new SyntaxError('Your brightnessThreshold is invalid; it needs to be a numeric value between 0 and 255.');
  }

  var stringValue = '' + value;
  var finalDefaultHex = getProperHex(defaultHex);
  var hexString = stringToHex(stringValue, finalDefaultHex);

  var rgbArray = stringToRgb(hexString);
  var rgbaArray = rgbArray.concat([opacity]);
  var hslArray = rgbToHsl(rgbArray);
  var hslaArray = hslArray.concat([opacity]);

  var hex = '#' + hexString;
  var rgb = 'rgb(' + rgbArray.join(', ') + ')';
  var rgba = 'rgba(' + rgbaArray.join(', ') + ')';
  var hsl = 'hsl(' + getHslaString(hslArray) + ')';
  var hsla = 'hsla(' + getHslaString(hslaArray) + ')';

  var shouldTextBeDark = shouldForegroundBeDark(rgbArray, brightnessThreshold);
  var shouldTextBeDarkW3C = shouldForegroundBeDarkW3C(rgbArray);

  var prisma = Object.create(null);

  prisma.hex = hex;

  prisma.rgb = rgb;
  prisma.rgbArray = OBJECT_FREEZE(rgbArray);

  prisma.rgba = rgba;
  prisma.rgbaArray = OBJECT_FREEZE(rgbaArray);

  prisma.hsl = hsl;
  prisma.hslArray = OBJECT_FREEZE(hslArray);

  prisma.hsla = hsla;
  prisma.hslaArray = OBJECT_FREEZE(hslaArray);

  prisma.shouldTextBeDark = shouldTextBeDark;
  prisma.shouldTextBeDarkW3C = shouldTextBeDarkW3C;

  return OBJECT_FREEZE(prisma);
};

/**
 * convenience function if you want to test if the foreground
 * should be dark based on a specific brightness level
 *
 * @param {string} color=DEFAULT_HEX_CODE_VALUE
 * @param {number} brightnessThreshold=BRIGHTNESS_THRESHOLD
 * @returns {boolean}
 */
createPrisma.shouldTextBeDark = function () {
  var color = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_HEX_CODE_VALUE : arguments[0];
  var brightnessThreshold = arguments.length <= 1 || arguments[1] === undefined ? BRIGHTNESS_THRESHOLD : arguments[1];

  if (brightnessThreshold < 0 || brightnessThreshold > 255) {
    throw new SyntaxError('Your brightnessThreshold is invalid; it needs to be a numeric value between 0 and 255.');
  }

  var properHex = getProperHex(color);
  var rgbArray = stringToRgb(properHex);

  return shouldForegroundBeDark(rgbArray, brightnessThreshold);
};

/**
 * convenience function if you want to test if the foreground
 * should be dark based on the W3C standard
 *
 * @param {string} color=DEFAULT_HEX_CODE_VALUE
 * @returns {boolean}
 */
createPrisma.shouldTextBeDarkWEC = function () {
  var color = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_HEX_CODE_VALUE : arguments[0];

  var properHex = getProperHex(color);
  var rgbArray = stringToRgb(properHex);

  return shouldForegroundBeDarkW3C(rgbArray);
};

exports.default = createPrisma;
module.exports = exports['default'];